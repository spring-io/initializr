This page describes the hal/json structure of the metadata exposed by the initializr. Such metadata can be used by third party clients to provide a list of options and default settings that can be used to request the creation of a project.

Each third-party client is advised to set a `User-Agent` header for *each* request sent to the service. A good structure for a user agent is `clientId/clientVersion` (i.e. `foo/1.2.0` for the "foo" client and version `1.2.0`).

== Content

Any third party client can retrieve the capabilities of the service by issuing a `GET` on the root URL using the following `Accept` header: `application/vnd.initializr.v2+json`. Please note that the metadata may evolve in a non backward compatible way in the future so adding this header ensures the service returns the metadata format you expect.

This is a full example of an output for a service running at `https://start.spring.io`:

.request
include::{snippets}/metadataWithV2AcceptHeader/http-request.adoc[]

.response
include::{snippets}/metadataWithV2AcceptHeader/http-response.adoc[]

The current capabilities are the following:

* Project dependencies: these are the _starters_ really or actually any dependency that we might want to add to the project.
* Project types: these define the action that can be invoked on this service and a description of what it would produce (for instance a zip holding a pre-configured Maven project). Each type may have one more tags that further define what it generates
* Packaging: the kind of projects to generate. This merely gives a hint to the component responsible to generate the project (for instance, generate an executable _jar_ project)
* Java version: the supported java versions
* Language: the language to use (e.g. Java)
* Boot version: the Spring Boot version to use
* Additional basic information such as: `groupId`, `artifactId`,  `version`, `name`, `description` and `packageName`

Each top-level attribute (i.e. capability) has a standard format:

* A `type` attribute that defines the semantic of the attribute (see below)
* A `default` attribute that defines either the default value or the reference to the default value
* A `values` attribute that defines the set of acceptable values (if any). This can be hierarchical (with `values` being held in `values`). Each item in a `values` array can have an `id`, `name` and `description`)

The following attribute `type` are supported:

* `text`: defines a simple text value with no option
* `single-select`: defines a simple value to be chosen amongst the specified options
* `hierarchical-multi-select`: defines a hierarchical set of values (values in values) with the ability to select multiple values
* `action`: a special type that defines the attribute defining the action to use

Each action is defined as a HAL-compliant URL. For instance, the `maven-project` type templated URL is defined as follows:

```json
"maven-project": {
  "href": "https://start.spring.io/starter.zip?type=maven-project{&dependencies,packaging,javaVersion,language,bootVersion,groupId,artifactId,version,name,description,packageName}",
  "templated": true
}
```

You can use Spring HATEOAS and the `UriTemplate` helper in particular to generate an URI from template variables. Note that the variables match the name of top-level attribute in the metadata document. If you can't parse such URI, the `action` attribute of each type gives you the root action to invoke on the server. This requires more manual handling on your end.

=== Project dependencies

A dependency is usually the coordinates of a _starter_ module but it can be just as well be a regular dependency. A typical dependency structure looks like this:

```json
{
  "name": "Display name",
  "id": "org.acme.project:project-starter-foo",
  "description": "What starter foo does"
}
```

The name is used as a display name to be shown in whatever UI used by the remote client. The id can be anything, really as the actual dependency definition is defined through configuration. If no id is defined, a default one is built using the `groupId` and `artifactId` of the dependency. Note in particular that the version is **never** used as part of an automatic id.

Each dependency belongs to a group. The idea of the group is to gather similar dependencies and order them. Here is a `core` group that illustrates this feature:

```json
{
  "name": "Core",
  "values": [
    {
      "name": "Security",
      "id": "security"
    },
    {
      "name": "Web",
      "id": "web"
    }
  ]
}
```

=== Project types

The `types` element defines what kind of project can be generated and how. For instance, if the service exposes the capability to generate a Maven project, this would look like this:

```json
{
  "id": "maven-project",
  "name": "Maven Project",
  "action": "/starter.zip",
  "tags": {
    "build": "maven",
    "format": "project"
  }
}
```

You should not rely on the output format depending that information. Always use the response headers that define a `Content-Type` and also a `Content-Disposition` header.

Note that each id has a related HAL-compliant link that can be used to generate a proper URI based on template variables. The top-level `type` has, as any other attribute, a `default` attribute that is a hint to select what the service consider to be a good default.

The `action` attribute defines the endpoint the client should contact to actually generate a project of that type if you can't use the HAL-compliant url.

The `tags` object is used to categorize the project type and give _hints_ to 3rd party client. For instance, the _build_ tag defines the build system the project is going to use and the _format_ tag defines the format of the generated content (i.e. here a complete project vs. a build file. Note that the `Content-type` header of the reply provides additional metadata).

=== Packaging

The `packaging` element defines the kind of project that should be generated. 

```json
{
  "name": "jar",
  "id": "java"
}
```

The obvious values for this element are `jar` and `war`.

=== Java version

The `javaVersion` element provides a list of possible java versions for the project:

```json
{
  "id": "1.7",
  "name": "1.7"
}
```

=== Languages

The `language` element provides a list of possible languages for the project:

```json
{
  "id": "java",
  "name": "Java"
}
```

=== Boot version

The `bootVersion` element provides the list of available boot versions

```json
{
  "id": "1.1.3.RELEASE",
  "name": "1.1.3"
}
```

== Defaults

Each top-level element has a `default` attribute that should be used as a hint to provide the default value in the relevant UI component.
